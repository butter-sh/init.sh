#!/usr/bin/env bash

# init.sh - Comprehensive arty.sh project initialization system
# Version: 1.0.0
# Generated by hammer.sh

set -euo pipefail

# Configuration
INIT_VERSION="1.0.0"
ARTY_HOME="${ARTY_HOME:-$PWD/.arty}"
CONFIG_FILE="${CONFIG_FILE:-arty.yml}"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
BOLD='\033[1m'
NC='\033[0m'

# Emoji support
EMOJI_CHECK="✓"
EMOJI_CROSS="✗"
EMOJI_ROCKET="🚀"
EMOJI_HAMMER="🔨"
EMOJI_PACKAGE="📦"
EMOJI_FOLDER="📁"
EMOJI_FILE="📄"
EMOJI_INFO="ℹ"
EMOJI_WARN="⚠"

# Logging functions
log_info() {
    echo -e "${BLUE}${EMOJI_INFO}${NC} $1"
}

log_success() {
    echo -e "${GREEN}${EMOJI_CHECK}${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}${EMOJI_WARN}${NC} $1"
}

log_error() {
    echo -e "${RED}${EMOJI_CROSS}${NC} $1" >&2
}

log_header() {
    echo -e "\n${BOLD}${CYAN}═══════════════════════════════════════════${NC}"
    echo -e "${BOLD}${CYAN}  $1${NC}"
    echo -e "${BOLD}${CYAN}═══════════════════════════════════════════${NC}\n"
}

# Banner
show_banner() {
    cat << 'EOF'

    ╦┌┐┌┬┌┬┐  ┌─┐┬ ┬
    ║││││ │   └─┐├─┤
    ╩┘└┘┴ ┴   └─┘┴ ┴
    
    Project Initialization System
    Part of the butter.sh ecosystem
    
EOF
}

# Show usage
show_usage() {
    cat << EOF
${BOLD}init.sh${NC} - Comprehensive arty.sh Project Initialization System

${BOLD}USAGE:${NC}
    init.sh [options] [project-name]

${BOLD}OPTIONS:${NC}
    ${GREEN}-t, --template${NC} <name>     Use a specific template (basic|web|cli|lib)
    ${GREEN}-d, --dir${NC} <path>          Target directory (default: current)
    ${GREEN}--skip-git${NC}                Skip git initialization
    ${GREEN}--skip-deps${NC}               Skip dependency installation
    ${GREEN}--interactive${NC}             Interactive mode with prompts
    ${GREEN}-v, --verbose${NC}             Verbose output
    ${GREEN}-h, --help${NC}                Show this help message
    ${GREEN}--version${NC}                 Show version information

${BOLD}TEMPLATES:${NC}
    ${CYAN}basic${NC}       Minimal project structure
    ${CYAN}cli${NC}         Command-line tool template
    ${CYAN}lib${NC}         Library/module template
    ${CYAN}web${NC}         Web service template

${BOLD}EXAMPLES:${NC}
    ${YELLOW}# Initialize with default template${NC}
    init.sh my-project

    ${YELLOW}# Interactive mode${NC}
    init.sh --interactive

    ${YELLOW}# CLI tool template${NC}
    init.sh --template cli my-awesome-cli

    ${YELLOW}# Library template in specific directory${NC}
    init.sh -t lib -d ~/projects my-library

${BOLD}PROJECT STRUCTURE:${NC}
    Generated projects include:
    • arty.yml configuration
    • README.md documentation
    • LICENSE file
    • .gitignore
    • Source structure
    • Example files
    • Setup hooks

${BOLD}INTEGRATION:${NC}
    Works seamlessly with:
    • ${CYAN}arty.sh${NC} - Library manager
    • ${CYAN}leaf.sh${NC} - Documentation generator
    • ${CYAN}hammer.sh${NC} - Project generator

${BOLD}VERSION:${NC}
    init.sh v${INIT_VERSION}

${BOLD}MORE INFO:${NC}
    GitHub: https://github.com/butter-sh/init.sh

EOF
}

# Show version
show_version() {
    cat << EOF
${BOLD}${CYAN}init.sh${NC} version ${GREEN}${INIT_VERSION}${NC}

Part of the ${BOLD}${CYAN}butter.sh${NC} ecosystem

${BOLD}Features:${NC}
  • Multiple project templates
  • Interactive initialization
  • Git integration
  • Dependency management
  • arty.yml generation

${BOLD}License:${NC} MIT
${BOLD}Website:${NC} https://init.sh
EOF
}

# Check if command exists
command_exists() {
    command -v "$1" &> /dev/null
}

# Check dependencies
check_dependencies() {
    local missing=()
    
    if ! command_exists "yq"; then
        missing+=("yq")
    fi
    
    if ! command_exists "git"; then
        missing+=("git")
    fi
    
    if [ ${#missing[@]} -gt 0 ]; then
        log_warn "Missing dependencies: ${missing[*]}"
        log_info "Install yq: https://github.com/mikefarah/yq#install"
        return 1
    fi
    
    return 0
}

# Create directory structure
create_structure() {
    local project_dir="$1"
    local template="$2"
    
    log_info "Creating project structure..."
    
    # Create base directories
    mkdir -p "$project_dir"/{src,lib,examples,tests,docs,.arty/{bin,libs}}
    
    # Template-specific directories
    case "$template" in
        web)
            mkdir -p "$project_dir"/{public,routes,middleware}
            ;;
        cli)
            mkdir -p "$project_dir"/{cmd,internal}
            ;;
        lib)
            mkdir -p "$project_dir"/{modules,utils}
            ;;
    esac
    
    log_success "Project structure created"
}

# Generate arty.yml
generate_arty_yml() {
    local project_dir="$1"
    local project_name="$2"
    local template="$3"
    
    log_info "Generating arty.yml..."
    
    local main_script="index.sh"
    case "$template" in
        cli) main_script="cmd/main.sh" ;;
        lib) main_script="lib/index.sh" ;;
        web) main_script="server.sh" ;;
    esac
    
    cat > "$project_dir/arty.yml" << EOF
name: "${project_name}"
version: "0.1.0"
description: "A new arty.sh project"
author: "$(git config user.name 2>/dev/null || echo '')"
license: "MIT"

# Project type: basic, cli, lib, web
type: "${template}"

# Dependencies from other arty.sh repositories
references:
  # Add your dependencies here
  # - https://github.com/user/bash-utils.git

# Entry point script
main: "${main_script}"

# Available commands/scripts
scripts:
  start: "bash ${main_script}"
  test: "bash tests/run-tests.sh"
  build: "bash scripts/build.sh"
  lint: "shellcheck src/**/*.sh"
  docs: "leaf.sh . -o docs"
  clean: "rm -rf build/ dist/"

# Environment variables
env:
  DEBUG: "0"
  LOG_LEVEL: "info"

# Project metadata
repository: ""
homepage: ""
bugs: ""

# Build configuration
build:
  output: "dist"
  target: "bash"
EOF

    log_success "Generated arty.yml"
}

# Generate README
generate_readme() {
    local project_dir="$1"
    local project_name="$2"
    local template="$3"
    
    log_info "Generating README.md..."
    
    cat > "$project_dir/README.md" << EOF
# ${project_name}

> A modern bash project powered by arty.sh

## 🚀 Quick Start

\`\`\`bash
# Install dependencies
arty deps

# Run the project
arty start

# Run tests
arty test
\`\`\`

## 📦 Installation

\`\`\`bash
# Clone the repository
git clone https://github.com/yourusername/${project_name}.git
cd ${project_name}

# Install with arty
arty install
\`\`\`

## 🛠️ Development

\`\`\`bash
# Run in development mode
bash index.sh

# Run tests
bash tests/run-tests.sh

# Generate documentation
arty docs
\`\`\`

## 📖 Documentation

Project documentation is automatically generated using leaf.sh:

\`\`\`bash
arty docs
open docs/index.html
\`\`\`

## 🏗️ Project Structure

\`\`\`
${project_name}/
├── arty.yml          # Project configuration
├── README.md         # This file
├── LICENSE           # MIT License
├── .gitignore        # Git ignore rules
├── index.sh          # Main entry point
├── src/              # Source files
├── lib/              # Libraries
├── examples/         # Example scripts
├── tests/            # Test files
├── docs/             # Documentation
└── .arty/            # arty.sh workspace
    ├── bin/          # Linked executables
    └── libs/         # Dependencies
\`\`\`

## 🎯 Features

- ✨ Modern bash development
- 📦 Dependency management with arty.sh
- 🧪 Built-in testing framework
- 📚 Auto-generated documentation
- 🔧 Configuration via arty.yml
- 🚀 Ready for distribution

## 🤝 Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## 📄 License

MIT License - see LICENSE file for details

## 🔗 Links

- [arty.sh](https://github.com/butter-sh/arty.sh) - Library manager
- [leaf.sh](https://github.com/butter-sh/leaf.sh) - Documentation generator
- [hammer.sh](https://github.com/butter-sh/hammer.sh) - Project generator

---

Made with ❤️ using the butter.sh ecosystem
EOF

    log_success "Generated README.md"
}

# Generate main script
generate_main_script() {
    local project_dir="$1"
    local project_name="$2"
    local template="$3"
    
    log_info "Generating main script..."
    
    local script_path="$project_dir/index.sh"
    
    cat > "$script_path" << 'EOF'
#!/usr/bin/env bash

# {{PROJECT_NAME}} - Main entry point
# Version: 0.1.0

set -euo pipefail

# Script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Load configuration
if [[ -f "$SCRIPT_DIR/arty.yml" ]]; then
    # Configuration available via yq
    PROJECT_NAME=$(yq eval '.name' "$SCRIPT_DIR/arty.yml" 2>/dev/null || echo "{{PROJECT_NAME}}")
    PROJECT_VERSION=$(yq eval '.version' "$SCRIPT_DIR/arty.yml" 2>/dev/null || echo "0.1.0")
else
    PROJECT_NAME="{{PROJECT_NAME}}"
    PROJECT_VERSION="0.1.0"
fi

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Logging
log_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
log_success() { echo -e "${GREEN}[OK]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1" >&2; }

# Show usage
show_usage() {
    cat << USAGE
${PROJECT_NAME} v${PROJECT_VERSION}

USAGE:
    $(basename "$0") [options] [command]

OPTIONS:
    -h, --help      Show this help
    -v, --version   Show version

COMMANDS:
    start           Start the application
    test            Run tests
    help            Show this help

EXAMPLES:
    $(basename "$0") start
    $(basename "$0") --help
USAGE
}

# Main logic
main() {
    case "${1:-help}" in
        start)
            log_info "Starting ${PROJECT_NAME}..."
            # Your application logic here
            log_success "Running!"
            ;;
        test)
            log_info "Running tests..."
            bash "$SCRIPT_DIR/tests/run-tests.sh"
            ;;
        -h|--help|help)
            show_usage
            ;;
        -v|--version)
            echo "${PROJECT_NAME} v${PROJECT_VERSION}"
            ;;
        *)
            log_error "Unknown command: $1"
            show_usage
            exit 1
            ;;
    esac
}

# Run if executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
EOF

    # Replace template variables
    sed -i "s|{{PROJECT_NAME}}|${project_name}|g" "$script_path"
    chmod +x "$script_path"
    
    log_success "Generated main script: index.sh"
}

# Generate test framework
generate_tests() {
    local project_dir="$1"
    
    log_info "Generating test framework..."
    
    cat > "$project_dir/tests/run-tests.sh" << 'EOF'
#!/usr/bin/env bash

# Test runner

set -euo pipefail

TESTS_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
TEST_COUNT=0
PASS_COUNT=0
FAIL_COUNT=0

# Colors
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
NC='\033[0m'

# Test helpers
assert_equals() {
    TEST_COUNT=$((TEST_COUNT + 1))
    if [[ "$1" == "$2" ]]; then
        PASS_COUNT=$((PASS_COUNT + 1))
        echo -e "${GREEN}✓${NC} Test $TEST_COUNT passed"
        return 0
    else
        FAIL_COUNT=$((FAIL_COUNT + 1))
        echo -e "${RED}✗${NC} Test $TEST_COUNT failed"
        echo "  Expected: $2"
        echo "  Got: $1"
        return 1
    fi
}

assert_contains() {
    TEST_COUNT=$((TEST_COUNT + 1))
    if [[ "$1" == *"$2"* ]]; then
        PASS_COUNT=$((PASS_COUNT + 1))
        echo -e "${GREEN}✓${NC} Test $TEST_COUNT passed"
        return 0
    else
        FAIL_COUNT=$((FAIL_COUNT + 1))
        echo -e "${RED}✗${NC} Test $TEST_COUNT failed"
        echo "  String '$1' does not contain '$2'"
        return 1
    fi
}

# Run all test files
echo "Running tests..."
echo

for test_file in "$TESTS_DIR"/*_test.sh; do
    if [[ -f "$test_file" ]]; then
        echo "Running $(basename "$test_file")..."
        bash "$test_file"
        echo
    fi
done

# Summary
echo "================================"
echo "Test Summary:"
echo "  Total: $TEST_COUNT"
echo -e "  ${GREEN}Passed: $PASS_COUNT${NC}"
if [[ $FAIL_COUNT -gt 0 ]]; then
    echo -e "  ${RED}Failed: $FAIL_COUNT${NC}"
    exit 1
else
    echo -e "  ${GREEN}All tests passed!${NC}"
fi
EOF

    chmod +x "$project_dir/tests/run-tests.sh"
    
    # Create example test
    cat > "$project_dir/tests/example_test.sh" << 'EOF'
#!/usr/bin/env bash

# Example test file

source "$(dirname "${BASH_SOURCE[0]}")/run-tests.sh"

# Test cases
assert_equals "hello" "hello"
assert_contains "hello world" "world"

echo "Example tests completed"
EOF

    chmod +x "$project_dir/tests/example_test.sh"
    
    log_success "Generated test framework"
}

# Generate .gitignore
generate_gitignore() {
    local project_dir="$1"
    
    log_info "Generating .gitignore..."
    
    cat > "$project_dir/.gitignore" << 'EOF'
# arty.sh
.arty/

# Build artifacts
dist/
build/
*.tar.gz
*.zip

# Logs
*.log
logs/

# OS files
.DS_Store
Thumbs.db

# Editor files
.vscode/
.idea/
*.swp
*.swo
*~

# Environment
.env
.env.local

# Temporary files
tmp/
temp/
*.tmp

# Node (if using)
node_modules/
package-lock.json

# Coverage
coverage/
.coverage

# Backup files
*.bak
*.backup
EOF

    log_success "Generated .gitignore"
}

# Generate LICENSE
generate_license() {
    local project_dir="$1"
    local project_name="$2"
    local year=$(date +%Y)
    local author=$(git config user.name 2>/dev/null || echo "Your Name")
    
    log_info "Generating LICENSE..."
    
    cat > "$project_dir/LICENSE" << EOF
MIT License

Copyright (c) ${year} ${author}

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
EOF

    log_success "Generated LICENSE"
}

# Initialize git repository
init_git() {
    local project_dir="$1"
    local skip_git="${2:-false}"
    
    if [[ "$skip_git" == "true" ]]; then
        log_info "Skipping git initialization"
        return
    fi
    
    log_info "Initializing git repository..."
    
    cd "$project_dir"
    
    if ! git init; then
        log_warn "Failed to initialize git repository"
        return
    fi
    
    git add .
    git commit -m "Initial commit - Generated by init.sh" &> /dev/null || true
    
    log_success "Git repository initialized"
}

# Install dependencies
install_deps() {
    local project_dir="$1"
    local skip_deps="${2:-false}"
    
    if [[ "$skip_deps" == "true" ]]; then
        log_info "Skipping dependency installation"
        return
    fi
    
    log_info "Installing dependencies..."
    
    cd "$project_dir"
    
    if command_exists "arty"; then
        if arty deps; then
            log_success "Dependencies installed"
        else
            log_warn "Failed to install dependencies"
        fi
    else
        log_warn "arty not found, skipping dependency installation"
    fi
}

# Interactive mode
interactive_init() {
    log_header "Interactive Project Initialization"
    
    # Project name
    read -p "Project name: " project_name
    [[ -z "$project_name" ]] && project_name="my-project"
    
    # Template
    echo "Available templates:"
    echo "  1) basic  - Minimal project"
    echo "  2) cli    - Command-line tool"
    echo "  3) lib    - Library/module"
    echo "  4) web    - Web service"
    read -p "Choose template (1-4): " template_choice
    
    case "$template_choice" in
        1) template="basic" ;;
        2) template="cli" ;;
        3) template="lib" ;;
        4) template="web" ;;
        *) template="basic" ;;
    esac
    
    # Directory
    read -p "Target directory [.]: " target_dir
    [[ -z "$target_dir" ]] && target_dir="."
    
    # Git
    read -p "Initialize git? [Y/n]: " init_git_choice
    skip_git="false"
    [[ "$init_git_choice" =~ ^[Nn] ]] && skip_git="true"
    
    # Dependencies
    read -p "Install dependencies? [Y/n]: " install_deps_choice
    skip_deps="false"
    [[ "$install_deps_choice" =~ ^[Nn] ]] && skip_deps="true"
    
    # Run initialization
    run_init "$project_name" "$template" "$target_dir" "$skip_git" "$skip_deps"
}

# Main initialization
run_init() {
    local project_name="$1"
    local template="${2:-basic}"
    local target_dir="${3:-.}"
    local skip_git="${4:-false}"
    local skip_deps="${5:-false}"
    
    local project_dir="$target_dir/$project_name"
    
    log_header "Initializing Project: $project_name"
    
    # Check if directory exists
    if [[ -d "$project_dir" ]]; then
        log_warn "Directory already exists: $project_dir"
        read -p "Continue anyway? [y/N]: " continue_choice
        [[ ! "$continue_choice" =~ ^[Yy] ]] && exit 1
    fi
    
    # Create structure
    create_structure "$project_dir" "$template"
    
    # Generate files
    generate_arty_yml "$project_dir" "$project_name" "$template"
    generate_readme "$project_dir" "$project_name" "$template"
    generate_main_script "$project_dir" "$project_name" "$template"
    generate_tests "$project_dir"
    generate_gitignore "$project_dir"
    generate_license "$project_dir" "$project_name"
    
    # Git initialization
    init_git "$project_dir" "$skip_git"
    
    # Install dependencies
    install_deps "$project_dir" "$skip_deps"
    
    # Success message
    log_header "Project Initialized Successfully!"
    
    cat << EOF
${GREEN}${EMOJI_ROCKET} Your project is ready!${NC}

${BOLD}Next steps:${NC}
  ${CYAN}cd $project_name${NC}
  ${CYAN}arty start${NC}

${BOLD}Available commands:${NC}
  ${YELLOW}arty start${NC}    - Start the application
  ${YELLOW}arty test${NC}     - Run tests
  ${YELLOW}arty docs${NC}     - Generate documentation
  ${YELLOW}arty deps${NC}     - Install dependencies

${BOLD}Project location:${NC}
  ${BLUE}$project_dir${NC}

${BOLD}Documentation:${NC}
  ${BLUE}https://github.com/butter-sh/init.sh${NC}

EOF
}

# Parse arguments
parse_args() {
    local project_name=""
    local template="basic"
    local target_dir="."
    local skip_git="false"
    local skip_deps="false"
    local interactive="false"
    local verbose="false"
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_usage
                exit 0
                ;;
            --version)
                show_version
                exit 0
                ;;
            -t|--template)
                template="$2"
                shift 2
                ;;
            -d|--dir)
                target_dir="$2"
                shift 2
                ;;
            --skip-git)
                skip_git="true"
                shift
                ;;
            --skip-deps)
                skip_deps="true"
                shift
                ;;
            --interactive)
                interactive="true"
                shift
                ;;
            -v|--verbose)
                verbose="true"
                set -x
                shift
                ;;
            -*)
                log_error "Unknown option: $1"
                show_usage
                exit 1
                ;;
            *)
                project_name="$1"
                shift
                ;;
        esac
    done
    
    # Handle interactive mode
    if [[ "$interactive" == "true" ]]; then
        interactive_init
        exit 0
    fi
    
    # Validate project name
    if [[ -z "$project_name" ]]; then
        log_error "Project name is required"
        echo
        show_usage
        exit 1
    fi
    
    # Run initialization
    run_init "$project_name" "$template" "$target_dir" "$skip_git" "$skip_deps"
}

# Main entry point
main() {
    show_banner
    
    # Check dependencies
    if ! check_dependencies; then
        log_error "Missing required dependencies"
        exit 1
    fi
    
    # Parse arguments
    parse_args "$@"
}

# Run if executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
